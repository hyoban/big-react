# 「17-2」实现并发更新Demo

在微任务调度中，没有「优先级」的概念，对于Scheduler存在5种优先级：

1. ImmediatePriority
1. UserBlockingPriority
1. NormalPriority
1. LowPriority
1. IdlePriority

引入优先级之后，整个调度过程变成了这样：

1. 找到最高优先级的任务
1. 满足调度策略的话，就开始调度
1. 任务正常执行完则移除，继续调度
1. 处理任务执行的中断问题
   1. 同步优先级不可中断
   1. 饥饿问题，不断增加优先级，过期了则变为同步优先级
   1. 时间切片，当前任务执行时间过长，时间切片用尽，则中断执行

需要考虑的情况：

1. 工作过程仅有一个 work
   1. 如果仅有一个 work，Scheduler 有个优化路径：如果调度的回调函数的返回值是函数，则会继续调度返回的函数
   1. 一个 work 的时候无需再次选择优先级最高的 work
1. 工作过程中产生相同优先级的work
   1. 如果优先级相同，则不需要开启新的调度
1. 工作过程中产生更高/低优先级的work
   1. 把握一个原则：我们每次选出的都是优先级最高的work。
